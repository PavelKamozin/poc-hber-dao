/*Copyright (c) 2019-2020 softserveinc.com All Rights Reserved.
 This software is the confidential and proprietary information of softserveinc.com You shall not disclose such Confidential Information and shall use it only in accordance
 with the terms of the source code license agreement you entered into with softserveinc.com*/
package softserve.hibernate.com.service.impl;

/*This is a Studio Managed File. DO NOT EDIT THIS FILE. Your changes may be reverted by Studio.*/

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectReader;
import com.wavemaker.runtime.data.expression.QueryFilter;
import com.wavemaker.runtime.data.model.AggregationInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import softserve.hibernate.com.dao.GenericDao;
import softserve.hibernate.com.entity.Role;
import softserve.hibernate.com.exception.InvalidInputException;
import softserve.hibernate.com.service.RoleService;

import javax.persistence.EntityNotFoundException;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * ServiceImpl object for domain model class Role.
 *
 * @see Role
 */
@Service("RoleServiceImpl")
public class RoleServiceImpl implements RoleService {

    private static final Logger LOGGER = LoggerFactory.getLogger(RoleServiceImpl.class);

    @Autowired
    @Qualifier("RoleDao")
    private GenericDao<Role, Integer> roleDao;

    @Autowired
    private ObjectMapper objectMapper;

    public void setRoleDao(GenericDao<Role, Integer> dao) {
        this.roleDao = dao;
    }

    @Transactional
    @Override
    public Role create(Role roles) {
        LOGGER.debug("Creating a new Role with information: {}", roles);

        Role rolesCreated = this.roleDao.create(roles);
        // reloading object from database to get database defined & server defined values.
        return this.roleDao.refresh(rolesCreated);
    }

    @Transactional(readOnly = true)
    @Override
    public Role getById(Integer rolesId) {
        LOGGER.debug("Finding Role by id: {}", rolesId);
        return this.roleDao.findById(rolesId);
    }

    @Transactional(readOnly = true)
    @Override
    public Role findById(Integer rolesId) {
        LOGGER.debug("Finding Role by id: {}", rolesId);
        try {
            return this.roleDao.findById(rolesId);
        } catch (EntityNotFoundException ex) {
            LOGGER.debug("No Role found with id: {}", rolesId, ex);
            return null;
        }
    }

    @Transactional(readOnly = true)
    @Override
    public List<Role> findByMultipleIds(List<Integer> rolesIds, boolean orderedReturn) {
        LOGGER.debug("Finding Role by ids: {}", rolesIds);

        return this.roleDao.findByMultipleIds(rolesIds, orderedReturn);
    }


    @Transactional(rollbackFor = EntityNotFoundException.class)
    @Override
    public Role update(Role roles) {
        LOGGER.debug("Updating Role with information: {}", roles);

        this.roleDao.update(roles);
        this.roleDao.refresh(roles);

        return roles;
    }

    @Transactional
    @Override
    public Role partialUpdate(Integer rolesId, Role role) {
        LOGGER.debug("Partially Updating the Role with id: {}", rolesId);

        Role roles = getById(rolesId);

        try {
            ObjectReader rolesReader = this.objectMapper.reader().forType(Role.class).withValueToUpdate(roles);
            roles = rolesReader.readValue(this.objectMapper.writeValueAsString(role));
        } catch (IOException ex) {
            LOGGER.debug("There was a problem in applying the patch: {}", role, ex);
            throw new InvalidInputException("Could not apply patch", ex);
        }

        roles = update(roles);

        return roles;
    }

    @Transactional
    @Override
    public Role delete(Integer rolesId) {
        LOGGER.debug("Deleting Role with id: {}", rolesId);
        Role deleted = this.roleDao.findById(rolesId);
        if (deleted == null) {
            LOGGER.debug("No Role found with id: {}", rolesId);
            throw new EntityNotFoundException("Role is not found for " + rolesId);
        }
        this.roleDao.delete(deleted);
        return deleted;
    }

    @Transactional
    @Override
    public void delete(Role roles) {
        LOGGER.debug("Deleting Role with {}", roles);
        this.roleDao.delete(roles);
    }

    @Transactional(readOnly = true)
    @Override
    public Page<Role> findAll(QueryFilter[] queryFilters, Pageable pageable) {
        LOGGER.debug("Finding all Role");
        return this.roleDao.search(queryFilters, pageable);
    }

    @Transactional(readOnly = true)
    @Override
    public Page<Role> findAll(String query, Pageable pageable) {
        LOGGER.debug("Finding all Role");
        return this.roleDao.searchByQuery(query, pageable);
    }

/*
    @Transactional(readOnly = true, timeout = 300)
    @Override
    public Downloadable export(ExportType exportType, String query, Pageable pageable) {
        LOGGER.debug("exporting data in the service db_hibernate for table Role to {} format", exportType);
        return this.roleDao.export(exportType, query, pageable);
    }

    @Transactional(readOnly = true, timeout = 300)
    @Override
    public void export(DataExportOptions options, Pageable pageable, OutputStream outputStream) {
        LOGGER.debug("exporting data in the service db_hibernate for table Role to {} format", options.getExportType());
        this.roleDao.export(options, pageable, outputStream);
    }
*/

    @Transactional(readOnly = true)
    @Override
    public long count(String query) {
        return this.roleDao.count(query);
    }

    @Transactional(readOnly = true)
    @Override
    public Page<Map<String, Object>> getAggregatedValues(AggregationInfo aggregationInfo, Pageable pageable) throws IllegalAccessException {
        return this.roleDao.getAggregatedValues(aggregationInfo, pageable);
    }



}